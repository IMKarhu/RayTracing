#version 460 core

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;

uniform vec3 CameraPosition;
uniform vec3 CameraForward;
uniform vec3 CameraRight;
uniform vec3 CameraUp;

const vec3 sunDirection = normalize(vec3(1.0, 0.5, 0.0));

struct Sphere
{
	vec3 Center;
	float Radius;
	vec3 Colour;
};

struct Ray
{
	vec3 RayOrigin;
	vec3 RayDirection;
};

bool hit(Ray ray, Sphere sphere, inout float t);

void main()
{
	vec3 pixel = vec3(0.0,0.0,0.0);
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	ivec2 dims = imageSize(screen);

	if(pixel_coords.x >= dims.x || pixel_coords.y >= dims.y)
	{
		return;
	}

	float x = (2.0 * pixel_coords.x - dims.x) / dims.x; // [-1.0, 1.0]
	float y = (2.0 * pixel_coords.y - dims.y) / dims.x; // [-1.0, 1.0]

	Ray m_Ray;
	float fov = 90.0;
	vec3 CameraOrigin = vec3(0.0,0.0, 1.0);
	m_Ray.RayOrigin = CameraPosition; // oli (x,y,0.0) nyt on (0.0,0.0,1.0)
	m_Ray.RayDirection = normalize(CameraForward + x * CameraRight + y * CameraUp);

	Sphere m_Sphere;
	m_Sphere.Center = vec3(3.0, 0.0, 0.0);
	m_Sphere.Radius = 1.0;
	m_Sphere.Colour = vec3(1.0, 0.75, 0.5);

	float t = 99999;

	//vec3 o_c = m_Ray.RayOrigin - m_Sphere.Center;
	//float b = dot(m_Ray.RayDirection, o_c);
	//float c = dot(o_c, o_c) - m_Sphere.Radius * m_Sphere.Radius;
	//float intersectionState = b * b - c;
	//vec3 intersection = m_Ray.RayOrigin + m_Ray.RayDirection * (-b + sqrt(b * b - c));

	if(hit(m_Ray, m_Sphere, t))
	{
		pixel = m_Sphere.Colour;
		vec3 hit_pos = m_Ray.RayOrigin + t * m_Ray.RayDirection;
		vec3 normal = normalize(hit_pos - m_Sphere.Center);
		float light_amount = max(0.0, dot(-sunDirection, normal));
		pixel = light_amount * m_Sphere.Colour;
	}

	imageStore(screen, pixel_coords, vec4(pixel, 1.0));
}


bool hit(Ray ray, Sphere sphere, inout float t)
{
	vec3 o_c = ray.RayOrigin - sphere.Center;
	float a = dot(ray.RayDirection, ray.RayDirection);
	float b = 2 * dot(ray.RayDirection, o_c);
	float c = dot(o_c, o_c) - sphere.Radius * sphere.Radius;
	float intersectionState = b * b - 4 * a * c;
	if(intersectionState < 0)
	{
		return false;
	}

	//vec3 intersection = ray.RayOrigin + ray.RayDirection * (-b + sqrt(b * b - c));
	float tHit = (-b - sqrt(intersectionState)) / (2 * a);
	if(tHit < t && tHit > 0.0001)
	{
		t = tHit;
		return true;
	}
	else
	{
		return false;
	}
	
}