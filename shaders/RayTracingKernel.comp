#version 460 core

struct Material
{
	vec3 m_Albeido;
	vec3 m_Specular;
	vec3 m_Emission;
	float m_Roughness;
};

struct Object
{
	vec3 m_ObjPosition;
	vec3 m_ObjScale;
	vec3 m_ObjColour;
	float m_ObjRadius;
	Material m_ObjMaterial;
};

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;

uniform vec3 CameraPosition;
uniform vec3 CameraForward;
uniform vec3 CameraRight;
uniform vec3 CameraUp;
uniform Object u_Objects[2];
uniform Object u_Objects1;
uniform Material u_Material;

const vec3 sunDirection = normalize(vec3(2.0, 0.5, -1.0));

struct Ray
{
	vec3 RayOrigin;
	vec3 RayDirection;
};

bool hit(Ray ray, Object sphere, inout float t);
bool boxHit(Ray ray, Object object, inout float t);
bool planeHit(vec3 planeNormal, vec3 planePosition,Ray ray, inout float t);

void main()
{
	vec3 pixel = vec3(0.5,0.5,0.5);
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	ivec2 dims = imageSize(screen);

	if(pixel_coords.x >= dims.x || pixel_coords.y >= dims.y)
	{
		return;
	}

	float x = (2.0 * pixel_coords.x - dims.x) / dims.x; // [-1.0, 1.0]
	float y = (2.0 * pixel_coords.y - dims.y) / dims.x; // [-1.0, 1.0]

	Ray m_Ray;
	m_Ray.RayOrigin = CameraPosition; // oli (x,y,0.0) nyt on (0.0,0.0,1.0)
	m_Ray.RayDirection = normalize(CameraForward + x * CameraRight + y * CameraUp);

	float t = 99999;
	float minHitDist = 10000;
	
	for(int i = 0; i < u_Objects.length(); ++i)
	{
		if(hit(m_Ray, u_Objects[i], t))
		{
			pixel = u_Objects[i].m_ObjColour;
			vec3 hit_pos = m_Ray.RayOrigin + t * m_Ray.RayDirection;
			vec3 normal = normalize(hit_pos - u_Objects[i].m_ObjPosition);
			float light_amount = max(0.0, dot(-sunDirection, normal));
			pixel = light_amount * u_Objects[i].m_ObjColour;
		}
	}


	imageStore(screen, pixel_coords, vec4(pixel, 1.0));
}


bool hit(Ray ray, Object sphere, inout float t)
{
	vec3 o_c = ray.RayOrigin - sphere.m_ObjPosition;
	float a = dot(ray.RayDirection, ray.RayDirection);
	float b = 2 * dot(ray.RayDirection, o_c);
	float c = dot(o_c, o_c) - sphere.m_ObjRadius * sphere.m_ObjRadius;
	float intersectionState = b * b - 4 * a * c;
	if(intersectionState < 0)
	{
		return false;
	}

	//vec3 intersection = ray.RayOrigin + ray.RayDirection * (-b + sqrt(b * b - c));
	float tHit = (-b - sqrt(intersectionState)) / (2 * a);
	if(tHit < t && tHit > 0.0001)
	{
		t = tHit;
		return true;
	}
	else
	{
		return false;
	}
	
}

bool boxHit(Ray ray, Object object, inout float t)
{
	float t1 = -1000000000000.0;
    float t2 = 1000000000000.0;

	vec3 boxMin = object.m_ObjPosition - object.m_ObjScale / 2.0;
	vec3 boxMax = object.m_ObjPosition + object.m_ObjScale / 2.0;

	vec3 t0s = (boxMin - ray.RayOrigin) / ray.RayDirection;
    vec3 t1s = (boxMax - ray.RayOrigin) / ray.RayDirection;

    vec3 tsmaller = min(t0s, t1s);
    vec3 tbigger = max(t0s, t1s);

    t1 = max(t1, max(tsmaller.x, max(tsmaller.y, tsmaller.z)));
    t2 = min(t2, min(tbigger.x, min(tbigger.y, tbigger.z)));

	t = t1;

	return t1 >= 0 && t1 <= t2;
}

bool planeHit(vec3 planeNormal, vec3 planePosition,Ray ray, inout float t)
{
	float denom = dot(planeNormal, ray.RayDirection); 
    if (abs(denom) > 0.0001) { 
        vec3 d = planePosition - ray.RayOrigin; 
        t = dot(d, planeNormal) / denom; 
        return (t >= 0.0001); 
    } 
 
    return false; 
}